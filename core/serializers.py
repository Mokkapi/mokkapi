from django.contrib.auth import get_user_model

from rest_framework import serializers

from .models import MockEndpoint, ResponseHandler, AuthenticationProfile


User = get_user_model()

# --- AuthenticationProfile Serializers ---
class AuthenticationProfileSerializer(serializers.ModelSerializer):
    # Make owner read-only, set automatically based on request user
    owner = serializers.PrimaryKeyRelatedField(read_only=True)
    # Hide password hash from output
    basic_auth_password_hash = serializers.CharField(write_only=True, required=False, allow_null=True, allow_blank=True, style={'input_type': 'password'})
    # Field to accept raw password input (not stored on model)
    password = serializers.CharField(write_only=True, required=False, allow_blank=True, style={'input_type': 'password'})

    class Meta:
        model = AuthenticationProfile
        fields = [
            'id', 'name', 'auth_type', 'api_key',
            'basic_auth_username', 'basic_auth_password_hash', # Write only hash
            'password', # Write only raw password field
            'owner', 'created_at', 'updated_at'
        ]
        read_only_fields = ['api_key', 'created_at', 'updated_at', 'owner'] # API key generated by model/view

    def validate(self, data):
        """Ensure required fields are present based on auth_type and handle password."""
        auth_type = data.get('auth_type', getattr(self.instance, 'auth_type', None))
        password = data.get('password')

        if auth_type == AuthenticationProfile.AuthType.BASIC:
            if not data.get('basic_auth_username', getattr(self.instance, 'basic_auth_username', None)):
                raise serializers.ValidationError({"basic_auth_username": "Username is required for Basic Auth."})
            # Require password only on create, or if explicitly provided on update
            if not self.instance and not password: # Creating new profile
                 raise serializers.ValidationError({"password": "Password is required for Basic Auth."})
            if password:
                 # We will hash this in create/update methods, remove raw password from validated_data
                 data.pop('password')
                 # Store the intent to set password for view/model logic
                 data['_set_password'] = password
            elif 'password' in data: # If password key exists but is empty/null on update, ignore hash update
                 data.pop('password')

        elif auth_type == AuthenticationProfile.AuthType.API_KEY:
            # Clear basic auth fields if type is API Key
            data['basic_auth_username'] = None
            data['basic_auth_password_hash'] = None # Ensure hash isn't set directly
            if 'password' in data: data.pop('password') # Remove if present

        # Remove write-only hash field if present but not needed (view will set it)
        if 'basic_auth_password_hash' in data:
             data.pop('basic_auth_password_hash')


        return data

    def create(self, validated_data):
        password_to_set = validated_data.pop('_set_password', None)
        # Owner is set in the view using perform_create
        instance = AuthenticationProfile.objects.create(**validated_data)
        if password_to_set and instance.auth_type == AuthenticationProfile.AuthType.BASIC:
            instance.set_password(password_to_set)
            instance.save(update_fields=['basic_auth_password_hash']) # Save only the hash
        return instance

    def update(self, instance, validated_data):
        password_to_set = validated_data.pop('_set_password', None)

        # Prevent changing auth_type after creation? Optional, but often good practice.
        validated_data.pop('auth_type', None) # Don't allow changing type via update

        instance = super().update(instance, validated_data)

        if password_to_set and instance.auth_type == AuthenticationProfile.AuthType.BASIC:
            instance.set_password(password_to_set)
            instance.save(update_fields=['basic_auth_password_hash']) # Save only the hash
        return instance


# --- ResponseHandler Serializers ---
class HandlerListSerializer(serializers.ListSerializer):
    def update(self, instances, validated_data_list):
        # map existing handlers by id
        instance_map = {inst.id: inst for inst in instances}
        data_map     = {data.get('id'): data for data in validated_data_list if data.get('id')}

        updated_instances = []

        # 1. Update or create each payload item
        for handler_data in validated_data_list:
            handler_id = handler_data.get('id', None)

            if handler_id and handler_id in instance_map:
                # update existing
                handler = instance_map[handler_id]
                for attr, val in handler_data.items():
                    setattr(handler, attr, val)
                handler.save()
                updated_instances.append(handler)
            else:
                # new handler
                # We expect the parent serializer to pass context['endpoint']
                endpoint = self.context['endpoint']
                updated_instances.append(
                    ResponseHandler.objects.create(endpoint=endpoint, **handler_data)
                )

        # 2. Delete any handlers not in the incoming list
        to_delete = [inst for inst_id, inst in instance_map.items()
                     if inst_id not in data_map]
        for inst in to_delete:
            inst.delete()

        return updated_instances

class ResponseHandlerSerializer(serializers.ModelSerializer):

    class Meta:
        model = ResponseHandler
        list_serializer = HandlerListSerializer
        fields = [
            'id', 'endpoint', 'http_method', 'response_status_code',
            'response_headers', 'response_body', 'description',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at']

    def validate_response_headers(self, value):
        """Ensure headers is a dictionary."""
        if not isinstance(value, dict):
            raise serializers.ValidationError("Headers must be a valid JSON object (dictionary).")
        # Optional: Validate Content-Type presence?
        # if 'Content-Type' not in value and 'content-type' not in value:
        #    raise serializers.ValidationError("Response headers should include 'Content-Type'.")
        return value

    def validate_response_body(self, value):
        """ Basic check, ensure it's a string """
        if not isinstance(value, str):
             raise serializers.ValidationError("Response body must be a string.")
        # More advanced: Try parsing if content-type is JSON/XML?
        # content_type = self.initial_data.get('response_headers', {}).get('Content-Type', '').lower()
        # if 'json' in content_type: try: json.loads(value) except: raise ...
        return value

# --- MockEndpoint Serializers ---

class MockEndpointSerializer(serializers.ModelSerializer):
    # Use the handler serializer for nested display (read-only)
    handlers = ResponseHandlerSerializer(many=True, read_only=True)
    # Allow setting authentication by ID
    authentication = serializers.PrimaryKeyRelatedField(
        queryset=AuthenticationProfile.objects.all(),
        allow_null=True,
        required=False,
        help_text="ID of the AuthenticationProfile to use (or null/omit for no auth)."
    )
    # Make creator/owner read-only if using UserTrackedModel with auto-population
    creator = serializers.PrimaryKeyRelatedField(read_only=True) # Assuming from UserTrackedModel
    owner = serializers.PrimaryKeyRelatedField(read_only=True) # Assuming from UserTrackedModel

    class Meta:
        model = MockEndpoint
        fields = [
            'id', 'path', 'description', 'authentication', 'handlers',
            'creator', 'owner', 'created_at', 'updated_at' # From UserTrackedModel
        ]
        read_only_fields = ['created_at', 'updated_at', 'creator', 'owner', 'handlers']

    def validate_authentication(self, value):
        """Ensure the requesting user owns the auth profile being assigned."""
        request = self.context.get('request')
        if value and request and hasattr(request, 'user'):
            if value.owner != request.user:
                 raise serializers.ValidationError("You can only assign authentication profiles that you own.")
        return value

# Serializer specifically for CREATING endpoints, includes initial handlers
class MockEndpointCreateSerializer(serializers.ModelSerializer):
    # Override handlers to be writeable for creation
    handlers = ResponseHandlerSerializer(many=True, required=True)

    class Meta:
        model = MockEndpoint
        fields = [
            'id', 'path', 'description', 'authentication',
            'handlers', 'creator', 'owner',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at', 'creator', 'owner'] # 'handlers' is now writable

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        child = self.fields['handlers'].child
        child.fields['endpoint'].require = False
        child.fields['endpoint'].read_only = True

    def validate_handlers(self, handlers_data):
        if not handlers_data:
            raise serializers.ValidationError("At least one handler definition is required.")
        methods = set()
        for handler in handlers_data:
            method = handler.get('http_method', '').upper()
            if not method:
                raise serializers.ValidationError("Each handler must have an 'http_method'.")
            if method in methods:
                 raise serializers.ValidationError(f"Duplicate http_method '{method}' found in handlers list.")
            methods.add(method)
        return handlers_data

    def create(self, validated_data):
        print("attempting create in create serializer")
        handlers_data = validated_data.pop('handlers')
        endpoint = MockEndpoint.objects.create(**validated_data)

        for handler_data in handlers_data:
            ResponseHandler.objects.create(endpoint=endpoint, **handler_data)
        return endpoint
    
    def update(self, instance, validated_data):
        handlers_data = validated_data.pop('handlers', None)

        for attr, val in validated_data.items():
            setattr(instance, attr, val)
        instance.save()

        if handlers_data is not None:
            # leverage our HandlerListSerializer
            serializer = ResponseHandlerSerializer(
                instance=instance.handlers.all(),
                data=handlers_data,
                many=True,
                context={'endpoint': instance}
            )
            serializer.is_valid(raise_exception=True)
            serializer.save()

        return instance